//******************************************************************
// 
//  Generated by IDL to C++ Translator
//  
//  File name: TempControl.h
//  Source: ../TempControl.idl
//  Generated: Fri Jun  8 15:07:10 2018
//  OpenSplice 6.7.180404OSS
//  
//******************************************************************
#ifndef _TEMPCONTROL_H_
#define _TEMPCONTROL_H_
#ifndef OPENSPLICE_ISOCXX_PSM
#define OPENSPLICE_ISOCXX_PSM
#endif

#include "sacpp_mapping.h"
#include <dds/core/ddscore.hpp>


namespace tutorial
{
   class TempSensorType;
   enum TemperatureScale
   {
      CELSIUS,
      FAHRENHEIT,
      KELVIN
   };

   class TempSensorType OSPL_DDS_FINAL
   {
   public:
         TempSensorType() {}
         explicit TempSensorType(
                  DDS::Short id,
                  DDS::Float temp,
                  DDS::Float hum,
                  TemperatureScale scale)         :
                           id_(id),
                           temp_(temp),
                           hum_(hum),
                           scale_(scale) {}
#ifdef OSPL_DDS_CXX11
#  ifdef OSPL_CXX11_NO_FUNCTION_DEFAULTS
         TempSensorType(const TempSensorType& _other)
         :
                           id_(_other.id_),
                           temp_(_other.temp_),
                           hum_(_other.hum_),
                           scale_(_other.scale_)
         {}
         TempSensorType(TempSensorType&& _other)
         :
                           id_(::std::move(_other.id_)),
                           temp_(::std::move(_other.temp_)),
                           hum_(::std::move(_other.hum_)),
                           scale_(::std::move(_other.scale_))
         {}
         TempSensorType& operator=(TempSensorType&& _other)
         {
                  if (this != &_other)
                  {
                           id_ = ::std::move(_other.id_);
                           temp_ = ::std::move(_other.temp_);
                           hum_ = ::std::move(_other.hum_);
                           scale_ = ::std::move(_other.scale_);
                  }
                  return *this;
         }
         TempSensorType& operator=(const TempSensorType& _other)
         {
                  if (this != &_other)
                  {
                           id_ = _other.id_;
                           temp_ = _other.temp_;
                           hum_ = _other.hum_;
                           scale_ = _other.scale_;
                  }
                  return *this;
         }
#  else
         TempSensorType(const TempSensorType& _other) = default;
         TempSensorType(TempSensorType&& _other) = default;
         TempSensorType& operator=(TempSensorType&& _other) = default;
         TempSensorType& operator=(const TempSensorType& _other) = default;
#  endif
#endif
         DDS::Short id() const { return this->id_; }
         DDS::Short& id() { return this->id_; }
         void id(DDS::Short _val_) { this->id_ = _val_; }
         DDS::Float temp() const { return this->temp_; }
         DDS::Float& temp() { return this->temp_; }
         void temp(DDS::Float _val_) { this->temp_ = _val_; }
         DDS::Float hum() const { return this->hum_; }
         DDS::Float& hum() { return this->hum_; }
         void hum(DDS::Float _val_) { this->hum_ = _val_; }
         TemperatureScale scale() const { return this->scale_; }
         TemperatureScale& scale() { return this->scale_; }
         void scale(TemperatureScale _val_) { this->scale_ = _val_; }
         bool operator==(const TempSensorType& _other) const
         {
                  return id_ == _other.id_ &&
                  temp_ == _other.temp_ &&
                  hum_ == _other.hum_ &&
                  scale_ == _other.scale_;
         }
         bool operator!=(const TempSensorType& other) const
         {
                  return !(*this == other);
         }
         DDS::Short id_;
         DDS::Float temp_;
         DDS::Float hum_;
         TemperatureScale scale_;
   };

}




#endif
